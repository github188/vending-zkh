/* jSSC (Java Simple Serial Connector) - serial port communication library.
 * Â© Alexey Sokolov (scream3r), 2010-2014.
 *
 * This file is part of jSSC.
 *
 * jSSC is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * jSSC is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with jSSC.  If not, see <http://www.gnu.org/licenses/>.
 *
 * If you use jSSC in public project you can inform me about this by e-mail,
 * of course if you want it.
 *
 * e-mail: scream3r.org@gmail.com
 * web-site: http://scream3r.org | http://code.google.com/p/java-simple-serial-connector/
 */
/* DO NOT EDIT THIS FILE - it is machine generated */
#include <jni.h>
/* Header for class jssc_SerialNativeInterface */

#ifndef _Included_jssc_SerialNativeInterface
#define _Included_jssc_SerialNativeInterface
#ifdef __cplusplus
extern "C" {
#endif

#undef jSSC_NATIVE_LIB_VERSION
#define jSSC_NATIVE_LIB_VERSION "2.8"

#undef jssc_SerialNativeInterface_OS_LINUX
#define jssc_SerialNativeInterface_OS_LINUX 0L
#undef jssc_SerialNativeInterface_OS_WINDOWS
#define jssc_SerialNativeInterface_OS_WINDOWS 1L
#undef jssc_SerialNativeInterface_OS_SOLARIS
#define jssc_SerialNativeInterface_OS_SOLARIS 2L
#undef jssc_SerialNativeInterface_OS_MAC_OS_X
#define jssc_SerialNativeInterface_OS_MAC_OS_X 3L
#undef jssc_SerialNativeInterface_ERR_PORT_BUSY
#define jssc_SerialNativeInterface_ERR_PORT_BUSY -1LL
#undef jssc_SerialNativeInterface_ERR_PORT_NOT_FOUND
#define jssc_SerialNativeInterface_ERR_PORT_NOT_FOUND -2LL
#undef jssc_SerialNativeInterface_ERR_PERMISSION_DENIED
#define jssc_SerialNativeInterface_ERR_PERMISSION_DENIED -3LL
#undef jssc_SerialNativeInterface_ERR_INCORRECT_SERIAL_PORT
#define jssc_SerialNativeInterface_ERR_INCORRECT_SERIAL_PORT -4LL

//---------------- serial.h -----------------

struct serial_struct {
	int	type;
	int	line;
	unsigned int	port;
	int	irq;
	int	flags;
	int	xmit_fifo_size;
	int	custom_divisor;
	int	baud_base;
	unsigned short	close_delay;
	char	io_type;
	char	reserved_char[1];
	int	hub6;
	unsigned short	closing_wait; /** time to wait before closing */
	unsigned short	closing_wait2; /** no longer used... */
	unsigned char	*iomem_base;
	unsigned short	iomem_reg_shift;
	unsigned int	port_high;
	unsigned long	iomap_base;	/** cookie passed into ioremap */
};

/**
 * Serial input interrupt line counters -- external structure
 * Four lines can interrupt: CTS, DSR, RI, DCD
 */
struct serial_icounter_struct {
	int cts, dsr, rng, dcd;
	int rx, tx;
	int frame, overrun, parity, brk;
	int buf_overrun;
	int reserved[9];
};

/**
 * For the close wait times, 0 means wait forever for serial port to
 * flush its output.  65535 means don't wait at all.
 */
#define ASYNC_CLOSING_WAIT_INF	0
#define ASYNC_CLOSING_WAIT_NONE	65535

/**
 * These are the supported serial types.
 */
#define PORT_UNKNOWN	0
#define PORT_8250	1
#define PORT_16450	2
#define PORT_16550	3
#define PORT_16550A	4
#define PORT_CIRRUS     5	/** usurped by cyclades.c */
#define PORT_16650	6
#define PORT_16650V2	7
#define PORT_16750	8
#define PORT_STARTECH	9	/** usurped by cyclades.c */
#define PORT_16C950	10	/** Oxford Semiconductor */
#define PORT_16654	11
#define PORT_16850	12
#define PORT_RSA	13	/** RSA-DV II/S card */
#define PORT_MAX	13

#define SERIAL_IO_PORT	0
#define SERIAL_IO_HUB6	1
#define SERIAL_IO_MEM	2

struct serial_uart_config {
	char	*name;
	int	dfl_xmit_fifo_size;
	int	flags;
};

#define UART_CLEAR_FIFO		0x01
#define UART_USE_FIFO		0x02
#define UART_STARTECH		0x04
#define UART_NATSEMI		0x08

/**
 * Definitions for async_struct (and serial_struct) flags field
 *
 * Define ASYNCB_* for convenient use with {test,set,clear}_bit.
 */
#define ASYNCB_HUP_NOTIFY	 0 /** Notify getty on hangups and closes
				    * on the callout port */
#define ASYNCB_FOURPORT		 1 /** Set OU1, OUT2 per AST Fourport settings */
#define ASYNCB_SAK		 2 /** Secure Attention Key (Orange book) */
#define ASYNCB_SPLIT_TERMIOS	 3 /** Separate termios for dialin/callout */
#define ASYNCB_SPD_HI		 4 /** Use 56000 instead of 38400 bps */
#define ASYNCB_SPD_VHI		 5 /** Use 115200 instead of 38400 bps */
#define ASYNCB_SKIP_TEST	 6 /** Skip UART test during autoconfiguration */
#define ASYNCB_AUTO_IRQ		 7 /** Do automatic IRQ during
				    * autoconfiguration */
#define ASYNCB_SESSION_LOCKOUT	 8 /** Lock out cua opens based on session */
#define ASYNCB_PGRP_LOCKOUT	 9 /** Lock out cua opens based on pgrp */
#define ASYNCB_CALLOUT_NOHUP	10 /** Don't do hangups for cua device */
#define ASYNCB_HARDPPS_CD	11 /** Call hardpps when CD goes high  */
#define ASYNCB_SPD_SHI		12 /** Use 230400 instead of 38400 bps */
#define ASYNCB_LOW_LATENCY	13 /** Request low latency behaviour */
#define ASYNCB_BUGGY_UART	14 /** This is a buggy UART, skip some safety
				    * checks.  Note: can be dangerous! */
#define ASYNCB_AUTOPROBE	15 /** Port was autoprobed by PCI or PNP code */
#define ASYNCB_LAST_USER	15

/** Internal flags used only by kernel */
#define ASYNCB_INITIALIZED	31 /** Serial port was initialized */
#define ASYNCB_SUSPENDED	30 /** Serial port is suspended */
#define ASYNCB_NORMAL_ACTIVE	29 /** Normal device is active */
#define ASYNCB_BOOT_AUTOCONF	28 /** Autoconfigure port on bootup */
#define ASYNCB_CLOSING		27 /** Serial port is closing */
#define ASYNCB_CTS_FLOW		26 /** Do CTS flow control */
#define ASYNCB_CHECK_CD		25 /** i.e., CLOCAL */
#define ASYNCB_SHARE_IRQ	24 /** for multifunction cards, no longer used */
#define ASYNCB_CONS_FLOW	23 /** flow control for console  */
#define ASYNCB_BOOT_ONLYMCA	22 /** Probe only if MCA bus */
#define ASYNCB_FIRST_KERNEL	22

#define ASYNC_HUP_NOTIFY	(1U << ASYNCB_HUP_NOTIFY)
#define ASYNC_SUSPENDED		(1U << ASYNCB_SUSPENDED)
#define ASYNC_FOURPORT		(1U << ASYNCB_FOURPORT)
#define ASYNC_SAK		(1U << ASYNCB_SAK)
#define ASYNC_SPLIT_TERMIOS	(1U << ASYNCB_SPLIT_TERMIOS)
#define ASYNC_SPD_HI		(1U << ASYNCB_SPD_HI)
#define ASYNC_SPD_VHI		(1U << ASYNCB_SPD_VHI)
#define ASYNC_SKIP_TEST		(1U << ASYNCB_SKIP_TEST)
#define ASYNC_AUTO_IRQ		(1U << ASYNCB_AUTO_IRQ)
#define ASYNC_SESSION_LOCKOUT	(1U << ASYNCB_SESSION_LOCKOUT)
#define ASYNC_PGRP_LOCKOUT	(1U << ASYNCB_PGRP_LOCKOUT)
#define ASYNC_CALLOUT_NOHUP	(1U << ASYNCB_CALLOUT_NOHUP)
#define ASYNC_HARDPPS_CD	(1U << ASYNCB_HARDPPS_CD)
#define ASYNC_SPD_SHI		(1U << ASYNCB_SPD_SHI)
#define ASYNC_LOW_LATENCY	(1U << ASYNCB_LOW_LATENCY)
#define ASYNC_BUGGY_UART	(1U << ASYNCB_BUGGY_UART)
#define ASYNC_AUTOPROBE		(1U << ASYNCB_AUTOPROBE)

#define ASYNC_FLAGS		((1U << (ASYNCB_LAST_USER + 1)) - 1)
#define ASYNC_USR_MASK		(ASYNC_SPD_HI|ASYNC_SPD_VHI| \
		ASYNC_CALLOUT_NOHUP|ASYNC_SPD_SHI|ASYNC_LOW_LATENCY)
#define ASYNC_SPD_CUST		(ASYNC_SPD_HI|ASYNC_SPD_VHI)
#define ASYNC_SPD_WARP		(ASYNC_SPD_HI|ASYNC_SPD_SHI)
#define ASYNC_SPD_MASK		(ASYNC_SPD_HI|ASYNC_SPD_VHI|ASYNC_SPD_SHI)

#define ASYNC_INITIALIZED	(1U << ASYNCB_INITIALIZED)
#define ASYNC_NORMAL_ACTIVE	(1U << ASYNCB_NORMAL_ACTIVE)
#define ASYNC_BOOT_AUTOCONF	(1U << ASYNCB_BOOT_AUTOCONF)
#define ASYNC_CLOSING		(1U << ASYNCB_CLOSING)
#define ASYNC_CTS_FLOW		(1U << ASYNCB_CTS_FLOW)
#define ASYNC_CHECK_CD		(1U << ASYNCB_CHECK_CD)
#define ASYNC_SHARE_IRQ		(1U << ASYNCB_SHARE_IRQ)
#define ASYNC_CONS_FLOW		(1U << ASYNCB_CONS_FLOW)
#define ASYNC_BOOT_ONLYMCA	(1U << ASYNCB_BOOT_ONLYMCA)
#define ASYNC_INTERNAL_FLAGS	(~((1U << ASYNCB_FIRST_KERNEL) - 1))

//---------------- serial.h -----------------

/*
 * Class:     jssc_SerialNativeInterface
 * Method:    getNativeLibraryVersion
 * Signature: ()Ljava/lang/String;
 */
JNIEXPORT jstring JNICALL Java_com_zillion_evm_jssc_SerialNativeInterface_getNativeLibraryVersion
  (JNIEnv *, jobject);

/*
 * Class:     jssc_SerialNativeInterface
 * Method:    openPort
 * Signature: (Ljava/lang/String;Z)J
 */
JNIEXPORT jlong JNICALL Java_com_zillion_evm_jssc_SerialNativeInterface_openPort
  (JNIEnv *, jobject, jstring, jboolean);

/*
 * Class:     jssc_SerialNativeInterface
 * Method:    setParams
 * Signature: (JIIIIZZI)Z
 */
JNIEXPORT jboolean JNICALL Java_com_zillion_evm_jssc_SerialNativeInterface_setParams
  (JNIEnv *, jobject, jlong, jint, jint, jint, jint, jboolean, jboolean, jint);

/*
 * Class:     jssc_SerialNativeInterface
 * Method:    purgePort
 * Signature: (JI)Z
 */
JNIEXPORT jboolean JNICALL Java_com_zillion_evm_jssc_SerialNativeInterface_purgePort
  (JNIEnv *, jobject, jlong, jint);

/*
 * Class:     jssc_SerialNativeInterface
 * Method:    closePort
 * Signature: (J)Z
 */
JNIEXPORT jboolean JNICALL Java_com_zillion_evm_jssc_SerialNativeInterface_closePort
  (JNIEnv *, jobject, jlong);

/*
 * Class:     jssc_SerialNativeInterface
 * Method:    setEventsMask
 * Signature: (JI)Z
 */
JNIEXPORT jboolean JNICALL Java_com_zillion_evm_jssc_SerialNativeInterface_setEventsMask
  (JNIEnv *, jobject, jlong, jint);

/*
 * Class:     jssc_SerialNativeInterface
 * Method:    getEventsMask
 * Signature: (J)I
 */
JNIEXPORT jint JNICALL Java_com_zillion_evm_jssc_SerialNativeInterface_getEventsMask
  (JNIEnv *, jobject, jlong);

/*
 * Class:     jssc_SerialNativeInterface
 * Method:    waitEvents
 * Signature: (J)[[I
 */
JNIEXPORT jobjectArray JNICALL Java_com_zillion_evm_jssc_SerialNativeInterface_waitEvents
  (JNIEnv *, jobject, jlong);

/*
 * Class:     jssc_SerialNativeInterface
 * Method:    setRTS
 * Signature: (JZ)Z
 */
JNIEXPORT jboolean JNICALL Java_com_zillion_evm_jssc_SerialNativeInterface_setRTS
  (JNIEnv *, jobject, jlong, jboolean);

/*
 * Class:     jssc_SerialNativeInterface
 * Method:    setDTR
 * Signature: (JZ)Z
 */
JNIEXPORT jboolean JNICALL Java_com_zillion_evm_jssc_SerialNativeInterface_setDTR
  (JNIEnv *, jobject, jlong, jboolean);

/*
 * Class:     jssc_SerialNativeInterface
 * Method:    readBytes
 * Signature: (JI)[B
 */
JNIEXPORT jbyteArray JNICALL Java_com_zillion_evm_jssc_SerialNativeInterface_readBytes
  (JNIEnv *, jobject, jlong, jint);

/*
 * Class:     jssc_SerialNativeInterface
 * Method:    writeBytes
 * Signature: (J[B)Z
 */
JNIEXPORT jboolean JNICALL Java_com_zillion_evm_jssc_SerialNativeInterface_writeBytes
  (JNIEnv *, jobject, jlong, jbyteArray);

/*
 * Class:     jssc_SerialNativeInterface
 * Method:    getBuffersBytesCount
 * Signature: (J)[I
 */
JNIEXPORT jintArray JNICALL Java_com_zillion_evm_jssc_SerialNativeInterface_getBuffersBytesCount
  (JNIEnv *, jobject, jlong);

/*
 * Class:     jssc_SerialNativeInterface
 * Method:    setFlowControlMode
 * Signature: (JI)Z
 */
JNIEXPORT jboolean JNICALL Java_com_zillion_evm_jssc_SerialNativeInterface_setFlowControlMode
  (JNIEnv *, jobject, jlong, jint);

/*
 * Class:     jssc_SerialNativeInterface
 * Method:    getFlowControlMode
 * Signature: (J)I
 */
JNIEXPORT jint JNICALL Java_com_zillion_evm_jssc_SerialNativeInterface_getFlowControlMode
  (JNIEnv *, jobject, jlong);

/*
 * Class:     jssc_SerialNativeInterface
 * Method:    getSerialPortNames
 * Signature: ()[Ljava/lang/String;
 */
JNIEXPORT jobjectArray JNICALL Java_com_zillion_evm_jssc_SerialNativeInterface_getSerialPortNames
  (JNIEnv *, jobject);

/*
 * Class:     jssc_SerialNativeInterface
 * Method:    getLinesStatus
 * Signature: (J)[I
 */
JNIEXPORT jintArray JNICALL Java_com_zillion_evm_jssc_SerialNativeInterface_getLinesStatus
  (JNIEnv *, jobject, jlong);

/*
 * Class:     jssc_SerialNativeInterface
 * Method:    sendBreak
 * Signature: (JI)Z
 */
JNIEXPORT jboolean JNICALL Java_com_zillion_evm_jssc_SerialNativeInterface_sendBreak
  (JNIEnv *, jobject, jlong, jint);

#ifdef __cplusplus
}
#endif
#endif
